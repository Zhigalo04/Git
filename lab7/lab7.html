<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
        }
        svg {
            border: 1px solid #e82121;
            cursor: crosshair;
        }
        select {
            margin-bottom: 10px;
        }
        .color-button {
            width: 30px;
            height: 30px;
            border: 1px solid #000;
            border-radius: 50%; /* Округлые кнопки */
            margin: 5px;
            cursor: pointer;
            display: inline-block; /* Расположение в одну линию */
        }
        .color-buttons {
            display: flex; /* Горизонтальное расположение кнопок */
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <select id="shapeSelector">
        <option value="circle">Круг</option>
        <option value="rectangle">Прямоугольник</option>
    </select>
    <div class="color-buttons">
        <div class="color-button" style="background-color: red;" data-color="red"></div>
        <div class="color-button" style="background-color: green;" data-color="green"></div>
        <div class="color-button" style="background-color: blue;" data-color="blue"></div>
        <div class="color-button" style="background-color: yellow;" data-color="yellow"></div>
        <div class="color-button" style="background-color: orange;" data-color="orange"></div>
    </div>
    <svg id="drawingArea" width="1200" height="600"></svg>

    <script>
        const drawingArea = document.getElementById('drawingArea');
        const shapeSelector = document.getElementById('shapeSelector');
        let isDrawing = false;
        let startX, startY;
    
        // Установка текущего цвета
        document.querySelectorAll('.color-button').forEach(button => {
            button.addEventListener('click', function() {
                currentColor = this.getAttribute('data-color');
            });
        });

        drawingArea.addEventListener('mousedown', (e) => {
            isDrawing = true;
            startX = e.offsetX;
            startY = e.offsetY;
        });

        drawingArea.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;

            const currentX = e.offsetX;
            const currentY = e.offsetY;
            const shape = shapeSelector.value;

            // Удаляем предыдущий временный элемент
            const tempShape = document.getElementById('tempShape');
            if (tempShape) tempShape.remove();

            if (shape === 'circle') {
                const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute('id', 'tempShape');
                circle.setAttribute('cx', startX);
                circle.setAttribute('cy', startY);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', currentColor);
                drawingArea.appendChild(circle);
            } else if (shape === 'rectangle') {
                const width = currentX - startX;
                const height = currentY - startY;
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute('id', 'tempShape');
                rect.setAttribute('x', Math.min(startX, currentX));
                rect.setAttribute('y', Math.min(startY, currentY));
                rect.setAttribute('width', Math.abs(width));
                rect.setAttribute('height', Math.abs(height));
                rect.setAttribute('fill', currentColor);
                drawingArea.appendChild(rect);
            }
        });

        drawingArea.addEventListener('mouseup', () => {
            if (isDrawing) {
                // Завершаем рисование фигуры
                const shape = shapeSelector.value;
                const currentX = event.offsetX;
                const currentY = event.offsetY;

                if (shape === 'circle') {
                    const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute('cx', startX);
                    circle.setAttribute('cy', startY);
                    circle.setAttribute('r', radius);
                    circle.setAttribute('fill', currentColor);
                    drawingArea.appendChild(circle);
                } else if (shape === 'rectangle') {
                    const width = currentX - startX;
                    const height = currentY - startY;
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', Math.min(startX, currentX));
                    rect.setAttribute('y', Math.min(startY, currentY));
                    rect.setAttribute('width', Math.abs(width));
                    rect.setAttribute('height', Math.abs(height));
                    rect.setAttribute('fill', currentColor);
                    drawingArea.appendChild(rect);
                }
            }
            isDrawing = false;
        });

        drawingArea.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Обработчик двойного клика для удаления фигур
        drawingArea.addEventListener('dblclick', (e) => {
            const shapes = document.elementsFromPoint(e.clientX, e.clientY);
            const clickedShape = shapes.find(shape => shape.tagName === 'circle' || shape.tagName === 'rect');

            if (clickedShape) {
                const confirmDelete = confirm('Вы действительно хотите удалить эту фигуру?');
                if (confirmDelete) {
                    clickedShape.remove();
                }
            }
        });

    </script>

</body>
</html>